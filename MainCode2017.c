#pragma config(Motor,  port2,           frontleftmotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           frontrightmotor, tmotorVex393, openLoop)
#pragma config(Motor,  port4,           rearleftmotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           rearrightmotor, tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//const tSensors kGyroPort = in1;  // Gyro





  word x, y, r;

  while (true) {
    /* Collect joystick & sensor values. */
    x = vexRT[kChX];  // X component.
    y = vexRT[kChY];  // Y component.
    r = vexRT[kChR];  // Rotation.

    /* Convert joystick values to polar. */
    radius = sqrt(pow(x, 2) + pow(y, 2));  // r = sqrt(x^2 + y^2)
    theta = (atan2(y, x) * (180 / PI));  // t = arctan(y / x) converted from radians to degrees.

    theta -= gyro;  // Adjust for gyro angle.

    /* Calculate opposite-side speeds. */
    a = ((cosDegrees(theta) - sinDegrees(theta)) * radius);  // Front-left and back-right.
    b = ((cosDegrees(theta) + sinDegrees(theta)) * radius);  // Front-right and back-left.

    /* Set speeds, including rotation. */
    wheelSpeed[0] = (a + r);  // Front-left.
    wheelSpeed[1] = (b - r);  // Front-right.
    wheelSpeed[2] = (b + r);  // Back-left.
    wheelSpeed[3] = (a - r);  // Back-right.

    /* Normalize speeds. */
    topSpeed = 0;
    for (ubyte i = 0; i < kNumbOfWheels; i++) {
      if (abs(wheelSpeed[i]) > topSpeed) {
        topSpeed = abs(wheelSpeed[i]);  // Find highest desired speed.
      }
    }
    if(topSpeed > 127) {
      for(ubyte i = 0; i < kNumbOfWheels; i++) {
        wheelSpeed[i] /= (topSpeed / 127);  // Downscale all speeds so none are above 127.
      }
    }

    /* Update motor powers. */
    for (ubyte i = 0; i < kNumbOfWheels; i++) {  // Cycle through all wheels.
      for (ubyte j = 0; j < kNumbOfMotorsPerWheel; j++) {  // Cycle through all motors for each wheel.
        if (kMotorPort[i][j] != kNone) {  // Check existence of motor.
          motor[kMotorPort[i][j]] = (word) wheelSpeed[i];  // Update motor power.
        }
      }
    }
    sleep(kLoopDelay);
  }
}

task main() {
  startTask(userDriveHolo);

  while (true) {
    sleep(100);
  }
}
